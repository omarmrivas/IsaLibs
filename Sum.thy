theory Sum
imports "IsaLibs/IsaLibs"
begin

section {* Summation *}

text {* This theory file shows how to find a function that multiplies natural numbers in Isabelle/HOL *}

text {* We first define the functional space of a destructor style functional scheme. *}

definition scheme_dest where
"scheme_dest N \<equiv> \<exists>(f::int list\<Rightarrow>int). \<forall>(xs::int list).
  f xs = N xs
           (\<lambda>x (y::int) z. if x then y else z)
           (op = :: int list\<Rightarrow>int list\<Rightarrow>bool)
           ([] :: int list)
           (op + :: int\<Rightarrow>int\<Rightarrow>int)
           (0 :: int)
           (\<lambda>xs. if xs = [] then (0::int) else hd xs)
           (tl :: int list\<Rightarrow>int list)
           f"

text {* Now we get the terminating closure of the destructor style functional scheme. *}

definition terminating_closure_scheme_dest where
"terminating_closure_scheme_dest N \<equiv> \<exists>f. \<forall>(xs::int list) (c\<^sub>f::nat) v\<^sub>f.
  ((f N 0 v\<^sub>f xs = v\<^sub>f) \<and>
   (f N (Suc c\<^sub>f) v\<^sub>f xs::int) = N xs
           (\<lambda>x (y::int) z. if x then y else z)
           (op = :: int list\<Rightarrow>int list\<Rightarrow>bool)
           ([] :: int list)
           (op + :: int\<Rightarrow>int\<Rightarrow>int)
           (0 :: int)
           (\<lambda>xs. if xs = [] then (0::int) else hd xs)
           (tl :: int list\<Rightarrow>int list)
           (f N c\<^sub>f v\<^sub>f))"

text {* All individuals generated by @{term "terminating_closure_scheme_dest"}
  are terminating, regardless the value of @{term "N"}. *}

fun f\<^sub>d where
"f\<^sub>d N (0::nat) v\<^sub>f (xs::int list) = (v\<^sub>f::int)" |
"f\<^sub>d N (Suc c\<^sub>f) v\<^sub>f xs = N xs
           (\<lambda>x (y::int) z. if x then y else z)
           (op = :: int list\<Rightarrow>int list\<Rightarrow>bool)
           ([] :: int list)
           (op + :: int\<Rightarrow>int\<Rightarrow>int)
           (0 :: int)
           (\<lambda>xs. if xs = [] then (0::int) else hd xs)
           (tl :: int list\<Rightarrow>int list)
           (f\<^sub>d N c\<^sub>f v\<^sub>f)"

theorem "terminating_closure_scheme_dest N"
apply (unfold terminating_closure_scheme_dest_def)
by (rule_tac x="f\<^sub>d" in exI, simp)

text {* Now we define the functional space of a constructor style functional scheme. *}

definition scheme_const where
"scheme_const N \<equiv> \<exists>(f::int list\<Rightarrow>int). \<forall>(xs::int list) (x::int).
  (f [] = (0::int)) \<and>
  (f (x#xs) = N x
                xs
                (op + :: int\<Rightarrow>int\<Rightarrow>int)
                f)"

text {* Now we get the terminating closure of the constructor style functional scheme. *}

definition terminating_closure_scheme_const where
"terminating_closure_scheme_const N \<equiv> \<exists>f. \<forall>(xs::int list) (x::int) c\<^sub>f v\<^sub>f.
  (f N 0 v\<^sub>f xs = v\<^sub>f) \<and>
  (f N (Suc c\<^sub>f) v\<^sub>f [] = (0::int)) \<and>
  (f N (Suc c\<^sub>f) v\<^sub>f (x#xs) = N x
                xs
                (op + :: int\<Rightarrow>int\<Rightarrow>int)
                (f N c\<^sub>f v\<^sub>f))"

fun f\<^sub>c where
"f\<^sub>c N 0 v\<^sub>f (xs::int list) = v\<^sub>f"|
"f\<^sub>c N (Suc c\<^sub>f) v\<^sub>f [] = (0::int)"|
"f\<^sub>c N (Suc c\<^sub>f) v\<^sub>f (x#xs) = N x
                xs
                (op + :: int\<Rightarrow>int\<Rightarrow>int)
                (f\<^sub>c N c\<^sub>f v\<^sub>f)"

text {* All individuals generated by @{term "terminating_closure_scheme_const"} 
  are well-defined, regardless the value of @{term "N"}} *}

theorem "terminating_closure_scheme_const N"
apply (unfold terminating_closure_scheme_const_def)
by (rule_tac x="f\<^sub>c" in exI, simp)

text {* We then define the fitness function, the termination criterion,
  and other GP related parameters.
*}

ML {*
  fun fitness ctxt functions =
    let val in_out = [(@{term "[] :: int list"},@{term "0::int"}),
                      (@{term "[1]:: int list"},@{term "1::int"}),
                      (@{term "[1,2]:: int list"},@{term "3::int"}),
                      (@{term "[1,2,3]:: int list"},@{term "6::int"}),
                      (@{term "[1,2,3,4]:: int list"},@{term "10::int"}),
                      (@{term "[1,2,3,4,5]:: int list"},@{term "15::int"}),
                      (@{term "[1,2,3,4,5,6]:: int list"},@{term "21::int"}),
                      (@{term "[1,2,3,4,5,6,7]:: int list"},@{term "28::int"}),
                      (@{term "[1,2,3,4,5,6,7,8]:: int list"},@{term "36::int"}),
                      (@{term "[1,2,3,4,5,6,7,8,9]:: int list"},@{term "45::int"})]
        val rec_counter = @{term "10::nat"}
        val vf = @{term "0 :: int"}
        val f = hd functions
        val error = 
          in_out |> map (fn (xs,r) => (Value.value ctxt (f $ rec_counter $ vf $ xs), r))
                 |> map (fn (i, r) => if i = r then 0 else 1)
    in (0, error) |> Library.foldl (op +)
                  |> Rat.rat_of_int end
  fun finish ({fit, ...} : GP.individual) = Rat.eq (Rat.zero, fit)
  fun test ctxt consts =
      consts |> fitness ctxt
             |> pair Rat.zero
             |> Rat.eq
  val term_size = 25
  val population_size = 200
  val generations = 1000
  val bests = 10
  val mut_prob = 0.05
  val scheme_dest = @{thm "scheme_dest_def"}
  val scheme_const = @{thm "scheme_const_def"}
  val functions_dest = [@{term "f\<^sub>d"}]
  val functions_const = [@{term "f\<^sub>c"}]
  val experiments = 20
  val recursive_calls = 1
  val bad_fitness = Rat.rat_of_int 10
*}

local_setup {*
  fn ctxt =>
    let val functions = [@{term "f\<^sub>d ((\<lambda>a b c d e f g h i. b (c d a) f (e (g a) (i (h a)))))"}]
        val r = fitness ctxt functions
        val _ = tracing (Rat.string_of_rat r)
    in ctxt end
*}

text {* We finally call the GP algorithm. *}

local_setup {*
 fn lthy =>
    let val experiment = GP.evolve true false scheme_const functions_const recursive_calls bad_fitness lthy fitness finish
                                   term_size population_size generations bests mut_prob
        val _ = MySQL.new_experiment "SumConsts" generations term_size population_size experiment
    in lthy end
*}

local_setup {*
 fn lthy =>
    let val experiment = GP.evolve true false scheme_dest functions_dest recursive_calls bad_fitness lthy fitness finish
                                   term_size population_size generations bests mut_prob
        val _ = MySQL.new_experiment "SumDest" generations term_size population_size experiment
    in lthy end
*}

(*local_setup {*
 fn lthy => 
    let val sts1 =
      1 upto experiments
        |> map (fn _ => GP.evolve true false scheme_const functions_const recursive_calls bad_fitness lthy fitness finish
                                  term_size population_size generations bests mut_prob)
        val (eqs1, alleq1) = GNU_Plot.gp_statistics_to_equals population_size sts1
        val _ = tracing ("gp_statistics_to_equals Constructive: (" ^ string_of_int eqs1 ^ ", " ^ string_of_int alleq1 ^ ")")
        val _ = GNU_Plot.gp_statistics_to_error_plot ("SumConsts" ^ string_of_int generations) generations sts1

        val sts2 =
      1 upto experiments
        |> map (fn _ => GP.evolve true false scheme_dest functions_dest recursive_calls bad_fitness lthy fitness finish
                                  term_size population_size generations bests mut_prob)
        val (eqs2, alleq2) = GNU_Plot.gp_statistics_to_equals population_size sts2
        val _ = tracing ("gp_statistics_to_equals Destructive: (" ^ string_of_int eqs2 ^ ", " ^ string_of_int alleq2 ^ ")")
        val _ = GNU_Plot.gp_statistics_to_error_plot ("SumDest" ^ string_of_int generations) generations sts2

        val _ = GNU_Plot.gp_statistics_to_cumulative_prob_plot ("Sum"^ string_of_int generations) generations sts1 sts2
    in lthy end
*}*)

end